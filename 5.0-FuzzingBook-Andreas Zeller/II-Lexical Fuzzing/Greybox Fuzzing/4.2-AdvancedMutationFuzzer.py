from fuzzingbook.Fuzzer import Fuzzer
from typing import List, Set, Any, Tuple, Dict, Union
from fuzzingbook.GreyboxFuzzer import Seed, Mutator, PowerSchedule
import random
import time
from fuzzingbook.MutationFuzzer import FunctionCoverageRunner
import matplotlib.pyplot as plt
from fuzzingbook.Coverage import population_coverage
class AdvancedMutationFuzzer(Fuzzer):
    """Base class for mutation-based fuzzing."""

    def __init__(self, seeds: List[str],
                 mutator: Mutator,
                 schedule: PowerSchedule) -> None:
        """Constructor.
        `seeds` - a list of (input) strings to mutate.
        `mutator` - the mutator to apply.
        `schedule` - the power schedule to apply.
        """
        self.seeds = seeds
        self.mutator = mutator
        self.schedule = schedule
        self.inputs: List[str] = []
        self.reset()

    def reset(self) -> None:
        """Reset the initial population and seed index"""
        self.population = list(map(lambda x: Seed(x), self.seeds))
        self.seed_index = 0

    def create_candidate(self) -> str:
        """Returns an input generated by fuzzing a seed in the population"""
        seed = self.schedule.choose(self.population)

        # Stacking: Apply multiple mutations to generate the candidate
        candidate = seed.data
        trials = min(len(candidate), 1 << random.randint(1, 5))
        for i in range(trials):
            candidate = self.mutator.mutate(candidate)
        return candidate

    def fuzz(self) -> str:
        """Returns first each seed once and then generates new inputs"""
        if self.seed_index < len(self.seeds):
            # Still seeding
            self.inp = self.seeds[self.seed_index]
            self.seed_index += 1
        else:
            # Mutating
            self.inp = self.create_candidate()

        self.inputs.append(self.inp)
        return self.inp
    
def crashme(s: str) -> None:
    if len(s) > 0 and s[0] == 'b':
        if len(s) > 1 and s[1] == 'a':
            if len(s) > 2 and s[2] == 'd':
                if len(s) > 3 and s[3] == '!':
                    raise Exception()
                
if __name__ == '__main__':
    n = 30000
    seed_input = "good"
    blackbox_fuzzer = AdvancedMutationFuzzer([seed_input], Mutator(), PowerSchedule())
    start = time.time()
    print(blackbox_fuzzer.fuzz())
    print(blackbox_fuzzer.fuzz())
    print(blackbox_fuzzer.fuzz())
    # 默认的PowerSchedule,即把每个种子的能量（权重）都为1
    # blackbox_fuzzer = AdvancedMutationFuzzer([seed_input], Mutator(), PowerSchedule())

    start = time.time()
    crashme_runner = FunctionCoverageRunner(crashme)
    blackbox_fuzzer.runs(crashme_runner, trials=n)
    # or
    # blackbox_fuzzer.runs(FunctionCoverageRunner(crashme), trials=n)
    end = time.time()
    print(f"It took the blackbox mutation-based fuzzer {end - start:.2f} seconds to generate and execute {n} inputs.")
    
    # Measure and plot coverage
    all_coverage, blackbox_coverage = population_coverage(blackbox_fuzzer.inputs, crashme)
    bb_max_coverage = max(blackbox_coverage)
    print(f"The blackbox mutation-based fuzzer achieved a maximum coverage of {bb_max_coverage} statements.")
    
    # # Plot coverage over time
    # plt.figure(figsize=(10, 6))
    # plt.plot(range(len(blackbox_coverage)), blackbox_coverage, label="Blackbox Fuzzer")
    # plt.title("Coverage over time")
    # plt.xlabel("Number of inputs")
    # plt.ylabel("Coverage")
    # plt.grid()
    # plt.legend()
    # plt.show()


